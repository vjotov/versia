<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>


	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta name="verify-v1" content="ynzW/GE7rr+SwTxuVauAHAJHCND7JANXtoLBw5Ci6tY=">
	<title>MySQL ::  Managing Hierarchical Data in MySQL</title> 

	 

	<link rel="stylesheet" type="text/css" media="screen" href="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/mysql_002.css">
	<link rel="stylesheet" type="text/css" media="projection" href="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/mysql.css">
	<link rel="stylesheet" type="text/css" media="print" href="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/print.css">
	
	 
		
		
		
		
	 
		<link rel="shortcut icon" href="http://dev.mysql.com/common/themes/sakila/favicon.ico">
	
		<script language="javascript" type="text/javascript" src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/clear_search_text.js"></script>
    	
		<noscript></noscript>
	    
		    
    
<!-- base href="http://dev.mysql.com/tech-resources/articles/hierarchical-data.html" --></head><body>

<div id="container">

<!--UdmComment-->
<a class="skipToContent" href="#mainContent">Skip navigation links</a>

	<div id="header">
	
	<div class="left">
		<div id="logo">
		    <span class="nobr"><a href="http://www.mysql.com/" title="MySQL.COM"><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/sakila.png" alt="MySQL.com" width="121" height="79"></a><a href="http://www.sun.com/" title="Sun.COM"><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/sun.png" alt="Sun Microsystems, Inc." width="95" height="79"></a></span>
		</div>
		<div id="sunsystems"><a href="http://www.sun.com/systems/solutions/mysql/?intcmp=2327">Recommended Servers for MySQL</a></div>
	
		<div id="tagline">The world's most popular open source database</div>
	</div>
	
	<div class="right">
		<div id="contact_rep"><a href="http://www.mysql.com/about/contact/" onclick="javascript: pageTracker._trackPageview('/FP/Contact-Rep-Button');">Contact a MySQL Representative</a></div>
		
		<div id="search_box"> <!-- Start Search -->
				    <form id="searchform" name="searchform" method="get" action="http://search.mysql.com/search">
			<input id="q" name="q" value="Search" class="swap_value" onfocus="clearSearchText();" type="text">
			<input name="ie" value="" type="hidden">
			<input name="lr" value="lang_en" type="hidden">
			<input src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/search_g.png" id="go" alt="Search" title="Search" value="Search" type="image">
		    </form>
		
		</div> <!-- End Search -->

				
		  		  
		<div id="login">
			
		  	
				
									 <p><a href="http://www.mysql.com/login/?dest=http%3a%2f%2fdev.mysql.com%2Ftech-resources%2Farticles%2Fhierarchical-data.html">Login</a> | <a href="http://www.mysql.com/register.php">Register</a></p>
									</div>
  
			</div>

	</div> 

	<!-- MySQL Navigation -->
	<div id="nav_container">
	
	<div id="flags">
            <ul>
		<br>
            </ul>
        </div>
	
	
		
		<div id="dev_nav">
	<ul>
		<li class="first"><a href="http://www.mysql.com/">MySQL.com</a></li>
		<li class="second"><a href="http://dev.mysql.com/downloads/" onclick="javascript: pageTracker._trackPageview('/FP/Tabs/Downloads');">Downloads</a></li>
		<li class="current"><a href="http://dev.mysql.com/">Developer Zone</a></li>
		<li><a href="http://solutions.mysql.com/?setlang=en">Partners &amp; Solutions</a></li>
		<li><a href="https://customer.mysql.com/">Customer Login</a></li>
	</ul>
	</div>
	
			
	<div id="mysql_menu">
	    <ul>
	<li class="current"><a class="current" href="http://dev.mysql.com/">DevZone</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://dev.mysql.com/doc/">Documentation</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://dev.mysql.com/librarian/">Librarian</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://dev.mysql.com/articles/">Articles</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://forums.mysql.com/">Forums</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://bugs.mysql.com/">Bugs</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://forge.mysql.com/">Forge</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://planet.mysql.com/">Planet MySQL</a>
	
		
		
	</li>
	
	<li class="link last"><a href="http://labs.mysql.com/">Labs</a>
	
		
		
	</li>
	
</ul>
	</div>

		<div id="og_sakila">&nbsp;</div>
	        <div id="og_title">&nbsp;</div>
	
	</div>
	<!-- End Navigation Container -->

<!--/UdmComment-->

<div class="page_container">

		
	 <div class="page_sidebar">
		
		<!--UdmComment-->
	
		<div id="menu_title">
				&nbsp;
		</div>
		
		<div id="menu">
				<ul>
	<li class="current"><a class="current" href="http://dev.mysql.com/tech-resources/articles/">Articles</a>
	
		
		
	</li>
	
	<li class="link"><a href="http://dev.mysql.com/tech-resources/interviews/">Interviews</a>
	
		
		
	</li>
	
	<li class="link last"><a href="http://dev.mysql.com/tech-resources/news/">Developer News</a>
	
		
		
	</li>
	
</ul> 
		</div>
	
		<br class="clear">
		
				
			
				
			
	
						<div id="related_pages">
				
<h3>About the Author</h3>
<img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/mhillyer.jpg" alt="Mike Hillyer" align="left" width="75" height="57" hspace="4">
<p>Mike Hillyer is a Technical Writer for MySQL AB and lives in Alberta, Canada.</p>
<br class="clear">
<div class="gray1"><hr></div>
<div class="promo1">
We are always looking for interesting articles
about MySQL! Have you written something and would like to it published
here? Please contact us via <a href="http://www.mysql.com/company/contact/?topic=community">feedback form »</a>
</div><br>

			</div>
				
					
			
			
							<div><a href="http://dev.mysql.com/click.php?e=35115"><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/h12-newsletter-subscribe.png" alt="MySQL Newsletter - Subscribe Today!" border="0" width="230" height="100"></a></div>
			
        				
							
			
										
				<div class="sidebarBannerAd">
					<script type="text/javascript">
					<!--
					google_ad_client = "pub-3255031602947757";
					google_ad_width = 160;
					google_ad_height = 600;
					google_ad_format = "160x600_as";
					google_ad_type = "text_image";

										
										google_ad_channel = "0028485735";
					google_color_border = "e0e0e0";
					google_color_bg = "fbfbfb";
					google_color_link = "00759f";
					google_color_url = "00759f";
					google_color_text = "000000";
					//-->
					</script>
					<noscript></noscript>
					<script type="text/javascript" src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/show_ads.js">
					</script><script src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/expansion_embed.js"></script><script src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/test_domain.js"></script><script>google_protectAndRun("ads_core.google_render_ad", google_handleError, google_render_ad);</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 600px; position: relative; visibility: visible; width: 160px;"><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 600px; position: relative; visibility: visible; width: 160px;"><iframe allowtransparency="true" hspace="0" id="google_ads_frame1" marginheight="0" marginwidth="0" name="google_ads_frame" src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/ads.htm" style="left: 0pt; position: absolute; top: 0pt;" vspace="0" scrolling="no" width="160" frameborder="0" height="600"></iframe></ins></ins>
					<noscript></noscript>
				</div>	
				
			
	<!--/UdmComment-->
	</div>		
	
	  
<!-- Main content -->
<a name="mainContent"></a>

<div id="page" class="sidebar">

	 
		<h1 class="page_header">Managing Hierarchical Data in MySQL</h1>
	 
	
	





	
<p class="byline">By Mike Hillyer</p>

<h3>Introduction</h3>

<p>Most users at one time or another have dealt with hierarchical data
in a SQL database and no doubt learned that the management of
hierarchical data is not what a relational database is intended for.
The tables of a relational database are not hierarchical (like XML),
but are simply a flat list. Hierarchical data has a parent-child
relationship that is not naturally represented in a relational database
table.</p>

<p>For our purposes, hierarchical data is a collection of data where
each item has a single parent and zero or more children (with the
exception of the root item, which has no parent). Hierarchical data can
be found in a variety of database applications, including forum and
mailing list threads, business organization charts, content management
categories, and product categories. For our purposes we will use the
following product category hierarchy from an fictional electronics
store:</p>

<p><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/hierarchical-data-1.png" width="100%"></p>

<p>These categories form a hierarchy in much the same way as the other
examples cited above. In this article we will examine two models for
dealing with hierarchical data in MySQL, starting with the traditional
adjacency list model.</p>

<h3>The Adjacency List Model</h3>

<p>Typically the example categories shown above will be stored in a
table like the following (I'm including full CREATE and INSERT
statements so you can follow along):</p>

<pre>CREATE TABLE category(
category_id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(20) NOT NULL,
parent INT DEFAULT NULL);


INSERT INTO category
VALUES(1,'ELECTRONICS',NULL),(2,'TELEVISIONS',1),(3,'TUBE',2),
(4,'LCD',2),(5,'PLASMA',2),(6,'PORTABLE ELECTRONICS',1),
(7,'MP3 PLAYERS',6),(8,'FLASH',7),
(9,'CD PLAYERS',6),(10,'2 WAY RADIOS',6);

SELECT * FROM category ORDER BY category_id;

+-------------+----------------------+--------+
| category_id | name                 | parent |
+-------------+----------------------+--------+
|           1 | ELECTRONICS          |   NULL |
|           2 | TELEVISIONS          |      1 |
|           3 | TUBE                 |      2 |
|           4 | LCD                  |      2 |
|           5 | PLASMA               |      2 |
|           6 | PORTABLE ELECTRONICS |      1 |
|           7 | MP3 PLAYERS          |      6 |
|           8 | FLASH                |      7 |
|           9 | CD PLAYERS           |      6 |
|          10 | 2 WAY RADIOS         |      6 |
+-------------+----------------------+--------+
10 rows in set (0.00 sec)
</pre>


<p>In the adjacency list model, each item in the table contains a
pointer to its parent. The topmost element, in this case electronics,
has a NULL value for its parent. The adjacency list model has the
advantage of being quite simple, it is easy to see that FLASH is a
child of mp3 players, which is a child of portable electronics, which
is a child of electronics. While the adjacency list model can be dealt
with fairly easily in client-side code, working with the model can be
more problematic in pure SQL.</p>

<h3>Retrieving a Full Tree</h3>

<p>The first common task when dealing with hierarchical data is the
display of the entire tree, usually with some form of indentation. The
most common way of doing this is in pure SQL is through the use of a
self-join:</p>

<pre>SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4
FROM category AS t1
LEFT JOIN category AS t2 ON t2.parent = t1.category_id
LEFT JOIN category AS t3 ON t3.parent = t2.category_id
LEFT JOIN category AS t4 ON t4.parent = t3.category_id
WHERE t1.name = 'ELECTRONICS';

+-------------+----------------------+--------------+-------+
| lev1        | lev2                 | lev3         | lev4  |
+-------------+----------------------+--------------+-------+
| ELECTRONICS | TELEVISIONS          | TUBE         | NULL  |
| ELECTRONICS | TELEVISIONS          | LCD          | NULL  |
| ELECTRONICS | TELEVISIONS          | PLASMA       | NULL  |
| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS  | FLASH |
| ELECTRONICS | PORTABLE ELECTRONICS | CD PLAYERS   | NULL  |
| ELECTRONICS | PORTABLE ELECTRONICS | 2 WAY RADIOS | NULL  |
+-------------+----------------------+--------------+-------+
6 rows in set (0.00 sec)
</pre>

<h3>Finding all the Leaf Nodes</h3>

<p>We can find all the leaf nodes in our tree (those with no children) by using a LEFT JOIN query:</p>

<pre>SELECT t1.name FROM
category AS t1 LEFT JOIN category as t2
ON t1.category_id = t2.parent
WHERE t2.category_id IS NULL;


+--------------+
| name         |
+--------------+
| TUBE         |
| LCD          |
| PLASMA       |
| FLASH        |
| CD PLAYERS   |
| 2 WAY RADIOS |
+--------------+
</pre>

<h3>Retrieving a Single Path</h3>

<p>The self-join also allows us to see the full path through our hierarchies:</p>

<pre>SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4
FROM category AS t1
LEFT JOIN category AS t2 ON t2.parent = t1.category_id
LEFT JOIN category AS t3 ON t3.parent = t2.category_id
LEFT JOIN category AS t4 ON t4.parent = t3.category_id
WHERE t1.name = 'ELECTRONICS' AND t4.name = 'FLASH';

+-------------+----------------------+-------------+-------+
| lev1        | lev2                 | lev3        | lev4  |
+-------------+----------------------+-------------+-------+
| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS | FLASH |
+-------------+----------------------+-------------+-------+
1 row in set (0.01 sec)
</pre>

<p>The main limitation of such an approach is that you need one
self-join for every level in the hierarchy, and performance will
naturally degrade with each level added as the joining grows in
complexity.</p>

<h3>Limitations of the Adjacency List Model</h3>

<p>Working with the adjacency list model in pure SQL can be difficult
at best. Before being able to see the full path of a category we have
to know the level at which it resides. In addition, special care must
be taken when deleting nodes because of the potential for orphaning an
entire sub-tree in the process (delete the portable electronics
category and all of its children are orphaned). Some of these
limitations can be addressed through the use of client-side code or
stored procedures. With a procedural language we can start at the
bottom of the tree and iterate upwards to return the full tree or a
single path. We can also use procedural programming to delete nodes
without orphaning entire sub-trees by promoting one child element and
re-ordering the remaining children to point to the new parent.</p>

<h3>The Nested Set Model</h3>

<p>What I would like to focus on in this article is a different approach, commonly referred to as the <b>Nested Set Model</b>.
In the Nested Set Model, we can look at our hierarchy in a new way, not
as nodes and lines, but as nested containers. Try picturing our
electronics categories this way:</p>

<p><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/hierarchical-data-2.png" width="100%"></p>

<p>Notice how our hierarchy is still maintained, as parent categories
envelop their children.We represent this form of hierarchy in a table
through the use of left and right values to represent the nesting of
our nodes:</p>

<pre>CREATE TABLE nested_category (
 category_id INT AUTO_INCREMENT PRIMARY KEY,
 name VARCHAR(20) NOT NULL,
 lft INT NOT NULL,
 rgt INT NOT NULL
);


INSERT INTO nested_category
VALUES(1,'ELECTRONICS',1,20),(2,'TELEVISIONS',2,9),(3,'TUBE',3,4),
(4,'LCD',5,6),(5,'PLASMA',7,8),(6,'PORTABLE ELECTRONICS',10,19),
(7,'MP3 PLAYERS',11,14),(8,'FLASH',12,13),
(9,'CD PLAYERS',15,16),(10,'2 WAY RADIOS',17,18);


SELECT * FROM nested_category ORDER BY category_id;


+-------------+----------------------+-----+-----+
| category_id | name                 | lft | rgt |
+-------------+----------------------+-----+-----+
|           1 | ELECTRONICS          |   1 |  20 |
|           2 | TELEVISIONS          |   2 |   9 |
|           3 | TUBE                 |   3 |   4 |
|           4 | LCD                  |   5 |   6 |
|           5 | PLASMA               |   7 |   8 |
|           6 | PORTABLE ELECTRONICS |  10 |  19 |
|           7 | MP3 PLAYERS          |  11 |  14 |
|           8 | FLASH                |  12 |  13 |
|           9 | CD PLAYERS           |  15 |  16 |
|          10 | 2 WAY RADIOS         |  17 |  18 |
+-------------+----------------------+-----+-----+
</pre>

<p>We use <b>lft</b> and <b>rgt</b> because left and right are reserved words in MySQL, see <a href="http://dev.mysql.com/doc/mysql/en/reserved-words.html">http://dev.mysql.com/doc/mysql/en/reserved-words.html</a> for the full list of reserved words.</p>

<p>So how do we determine left and right values? We start numbering at
the leftmost side of the outer node and continue to the right:</p>

<p><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/hierarchical-data-3.png" width="100%"></p>

<p>This design can be applied to a typical tree as well:</p>

<p><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/hierarchical-data-4.png" width="100%"></p>

<p>When working with a tree, we work from left to right, one layer at a
time, descending to each node's children before assigning a right-hand
number and moving on to the right. This approach is called the modified
<b>preorder tree traversal algorithm.</b></p>

<h3>Retrieving a Full Tree</h3>

<p>We can retrieve the full tree through the use of a self-join that links parents with nodes on the basis that a node's <b>lft</b> value will always appear between its parent's <b>lft</b> and <b>rgt</b> values:</p>

<pre>SELECT node.name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
AND parent.name = 'ELECTRONICS'
ORDER BY node.lft;


+----------------------+
| name                 |
+----------------------+
| ELECTRONICS          |
| TELEVISIONS          |
| TUBE                 |
| LCD                  |
| PLASMA               |
| PORTABLE ELECTRONICS |
| MP3 PLAYERS          |
| FLASH                |
| CD PLAYERS           |
| 2 WAY RADIOS         |
+----------------------+
</pre>

<p>Unlike our previous examples with the adjacency list model, this
query will work regardless of the depth of the tree. We do not concern
ourselves with the rgt value of the node in our BETWEEN clause because
the rgt value will always fall within the same parent as the lft values.</p>

<h3>Finding all the Leaf Nodes</h3>

<p>Finding all leaf nodes in the nested set model even simpler than the
LEFT JOIN method used in the adjacency list model. If you look at the
nested_category table, you may notice that the lft and rgt values for
leaf nodes are consecutive numbers. To find the leaf nodes, we look for
nodes where rgt = lft + 1:</p>

<pre>SELECT name
FROM nested_category
WHERE rgt = lft + 1;


+--------------+
| name         |
+--------------+
| TUBE         |
| LCD          |
| PLASMA       |
| FLASH        |
| CD PLAYERS   |
| 2 WAY RADIOS |
+--------------+
</pre>

<h3>Retrieving a Single Path</h3>

<p>With the nested set model, we can retrieve a single path without having multiple self-joins:</p>

<pre>SELECT parent.name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
AND node.name = 'FLASH'
ORDER BY parent.lft;

+----------------------+
| name                 |
+----------------------+
| ELECTRONICS          |
| PORTABLE ELECTRONICS |
| MP3 PLAYERS          |
| FLASH                |
+----------------------+
</pre>

<h3>Finding the Depth of the Nodes</h3>

<p>We have already looked at how to show the entire tree, but what if
we want to also show the depth of each node in the tree, to better
identify how each node fits in the hierarchy? This can be done by
adding a COUNT function and a GROUP BY clause to our existing query for
showing the entire tree:</p>

<pre>SELECT node.name, (COUNT(parent.name) - 1) AS depth
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;

+----------------------+-------+
| name                 | depth |
+----------------------+-------+
| ELECTRONICS          |     0 |
| TELEVISIONS          |     1 |
| TUBE                 |     2 |
| LCD                  |     2 |
| PLASMA               |     2 |
| PORTABLE ELECTRONICS |     1 |
| MP3 PLAYERS          |     2 |
| FLASH                |     3 |
| CD PLAYERS           |     2 |
| 2 WAY RADIOS         |     2 |
+----------------------+-------+
</pre>

<p>We can use the depth value to indent our category names with the CONCAT and REPEAT string functions:</p>

<pre>SELECT CONCAT( REPEAT(' ', COUNT(parent.name) - 1), node.name) AS name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;

+-----------------------+
| name                  |
+-----------------------+
| ELECTRONICS           |
|  TELEVISIONS          |
|   TUBE                |
|   LCD                 |
|   PLASMA              |
|  PORTABLE ELECTRONICS |
|   MP3 PLAYERS         |
|    FLASH              |
|   CD PLAYERS          |
|   2 WAY RADIOS        |
+-----------------------+
</pre>

<p>Of course, in a client-side application you will be more likely to
use the depth value directly to display your hierarchy. Web developers
could loop through the tree, adding &lt;li&gt;&lt;/li&gt; and
&lt;ul&gt;&lt;/ul&gt; tags as the depth number increases and decreases.</p>

<h3>Depth of a Sub-Tree</h3>

<p>When we need depth information for a sub-tree, we cannot limit
either the node or parent tables in our self-join because it will
corrupt our results. Instead, we add a third self-join, along with a
sub-query to determine the depth that will be the new starting point
for our sub-tree:</p>

<pre>SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth
FROM nested_category AS node,
	nested_category AS parent,
	nested_category AS sub_parent,
	(
		SELECT node.name, (COUNT(parent.name) - 1) AS depth
		FROM nested_category AS node,
		nested_category AS parent
		WHERE node.lft BETWEEN parent.lft AND parent.rgt
		AND node.name = 'PORTABLE ELECTRONICS'
		GROUP BY node.name
		ORDER BY node.lft
	)AS sub_tree
WHERE node.lft BETWEEN parent.lft AND parent.rgt
	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt
	AND sub_parent.name = sub_tree.name
GROUP BY node.name
ORDER BY node.lft;


+----------------------+-------+
| name                 | depth |
+----------------------+-------+
| PORTABLE ELECTRONICS |     0 |
| MP3 PLAYERS          |     1 |
| FLASH                |     2 |
| CD PLAYERS           |     1 |
| 2 WAY RADIOS         |     1 |
+----------------------+-------+
</pre>

<p>This function can be used with any node name, including the root node. The depth values are always relative to the named node.</p>

<h3>Find the Immediate Subordinates of a Node</h3>

<p>Imagine you are showing a category of electronics products on a
retailer web site. When a user clicks on a category, you would want to
show the products of that category, as well as list its immediate
sub-categories, but not the entire tree of categories beneath it. For
this, we need to show the node and its immediate sub-nodes, but no
further down the tree. For example, when showing the PORTABLE
ELECTRONICS category, we will want to show MP3 PLAYERS, CD PLAYERS, and
2 WAY RADIOS, but not FLASH.</p>

<p>This can be easily accomplished by adding a HAVING clause to our previous query:</p>

<pre>SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth
FROM nested_category AS node,
	nested_category AS parent,
	nested_category AS sub_parent,
	(
		SELECT node.name, (COUNT(parent.name) - 1) AS depth
		FROM nested_category AS node,
		nested_category AS parent
		WHERE node.lft BETWEEN parent.lft AND parent.rgt
		AND node.name = 'PORTABLE ELECTRONICS'
		GROUP BY node.name
		ORDER BY node.lft
	)AS sub_tree
WHERE node.lft BETWEEN parent.lft AND parent.rgt
	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt
	AND sub_parent.name = sub_tree.name
GROUP BY node.name
HAVING depth &lt;= 1
ORDER BY node.lft;

+----------------------+-------+
| name                 | depth |
+----------------------+-------+
| PORTABLE ELECTRONICS |     0 |
| MP3 PLAYERS          |     1 |
| CD PLAYERS           |     1 |
| 2 WAY RADIOS         |     1 |
+----------------------+-------+
</pre>

<p>If you do not wish to show the parent node, change the <b>HAVING depth &lt;= 1 line to HAVING depth = 1</b>.</p>

<h3>Aggregate Functions in a Nested Set</h3>

<p>Let's add a table of products that we can use to demonstrate aggregate functions with:</p>

<pre>CREATE TABLE product(
product_id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(40),
category_id INT NOT NULL
);


INSERT INTO product(name, category_id) VALUES('20" TV',3),('36" TV',3),
('Super-LCD 42"',4),('Ultra-Plasma 62"',5),('Value Plasma 38"',5),
('Power-MP3 5gb',7),('Super-Player 1gb',8),('Porta CD',9),('CD To go!',9),
('Family Talk 360',10);

SELECT * FROM product;

+------------+-------------------+-------------+
| product_id | name              | category_id |
+------------+-------------------+-------------+
|          1 | 20" TV            |           3 |
|          2 | 36" TV            |           3 |
|          3 | Super-LCD 42"     |           4 |
|          4 | Ultra-Plasma 62"  |           5 |
|          5 | Value Plasma 38"  |           5 |
|          6 | Power-MP3 128mb   |           7 |
|          7 | Super-Shuffle 1gb |           8 |
|          8 | Porta CD          |           9 |
|          9 | CD To go!         |           9 |
|         10 | Family Talk 360   |          10 |
+------------+-------------------+-------------+
</pre>

<p>Now let's produce a query that can retrieve our category tree, along with a product count for each category:</p>

<pre>SELECT parent.name, COUNT(product.name)
FROM nested_category AS node ,
nested_category AS parent,
product
WHERE node.lft BETWEEN parent.lft AND parent.rgt
AND node.category_id = product.category_id
GROUP BY parent.name
ORDER BY node.lft;


+----------------------+---------------------+
| name                 | COUNT(product.name) |
+----------------------+---------------------+
| ELECTRONICS          |                  10 |
| TELEVISIONS          |                   5 |
| TUBE                 |                   2 |
| LCD                  |                   1 |
| PLASMA               |                   2 |
| PORTABLE ELECTRONICS |                   5 |
| MP3 PLAYERS          |                   2 |
| FLASH                |                   1 |
| CD PLAYERS           |                   2 |
| 2 WAY RADIOS         |                   1 |
+----------------------+---------------------+
</pre>

<p>This is our typical whole tree query with a COUNT and GROUP BY
added, along with a reference to the product table and a join between
the node and product table in the WHERE clause. As you can see, there
is a count for each category and the count of subcategories is
reflected in the parent categories.</p>

<h3>Adding New Nodes</h3>

<p>Now that we have learned how to query our tree, we should take a
look at how to update our tree by adding a new node. Let's look at our
nested set diagram again:</p>

<p><img src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/hierarchical-data-5.png" width="100%"></p>

<p>If we wanted to add a new node between the TELEVISIONS and PORTABLE
ELECTRONICS nodes, the new node would have lft and rgt values of 10 and
11, and all nodes to its right would have their lft and rgt values
increased by two. We would then add the new node with the appropriate
lft and rgt values. While this can be done with a stored procedure in
MySQL 5, I will assume for the moment that most readers are using 4.1,
as it is the latest stable version, and I will isolate my queries with
a LOCK TABLES statement instead:</p>

<pre>LOCK TABLE nested_category WRITE;


SELECT @myRight := rgt FROM nested_category
WHERE name = 'TELEVISIONS';



UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myRight;
UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myRight;

INSERT INTO nested_category(name, lft, rgt) VALUES('GAME CONSOLES', @myRight + 1, @myRight + 2);

UNLOCK TABLES;

We can then check our nesting with our indented tree query:

SELECT CONCAT( REPEAT( ' ', (COUNT(parent.name) - 1) ), node.name) AS name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;


+-----------------------+
| name                  |
+-----------------------+
| ELECTRONICS           |
|  TELEVISIONS          |
|   TUBE                |
|   LCD                 |
|   PLASMA              |
|  GAME CONSOLES        |
|  PORTABLE ELECTRONICS |
|   MP3 PLAYERS         |
|    FLASH              |
|   CD PLAYERS          |
|   2 WAY RADIOS        |
+-----------------------+
</pre>

<p>If we instead want to add a node as a child of a node that has no
existing children, we need to modify our procedure slightly. Let's add
a new FRS node below the 2 WAY RADIOS node:</p>

<pre>LOCK TABLE nested_category WRITE;

SELECT @myLeft := lft FROM nested_category

WHERE name = '2 WAY RADIOS';

UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myLeft;
UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myLeft;

INSERT INTO nested_category(name, lft, rgt) VALUES('FRS', @myLeft + 1, @myLeft + 2);

UNLOCK TABLES;
</pre>

<p>In this example we expand everything to the right of the left-hand
number of our proud new parent node, then place the node to the right
of the left-hand value. As you can see, our new node is now properly
nested:</p>

<pre>SELECT CONCAT( REPEAT( ' ', (COUNT(parent.name) - 1) ), node.name) AS name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;


+-----------------------+
| name                  |
+-----------------------+
| ELECTRONICS           |
|  TELEVISIONS          |
|   TUBE                |
|   LCD                 |
|   PLASMA              |
|  GAME CONSOLES        |
|  PORTABLE ELECTRONICS |
|   MP3 PLAYERS         |
|    FLASH              |
|   CD PLAYERS          |
|   2 WAY RADIOS        |
|    FRS                |
+-----------------------+
</pre>

<h3>Deleting Nodes</h3>

<p>The last basic task involved in working with nested sets is the
removal of nodes. The course of action you take when deleting a node
depends on the node's position in the hierarchy; deleting leaf nodes is
easier than deleting nodes with children because we have to handle the
orphaned nodes.</p>

<p>When deleting a leaf node, the process if just the opposite of
adding a new node, we delete the node and its width from every node to
its right:</p>

<pre>LOCK TABLE nested_category WRITE;


SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1
FROM nested_category
WHERE name = 'GAME CONSOLES';


DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;


UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;
UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;

UNLOCK TABLES;
</pre>

<p>And once again, we execute our indented tree query to confirm that our node has been deleted without corrupting the hierarchy:</p>

<pre>SELECT CONCAT( REPEAT( ' ', (COUNT(parent.name) - 1) ), node.name) AS name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;


+-----------------------+
| name                  |
+-----------------------+
| ELECTRONICS           |
|  TELEVISIONS          |
|   TUBE                |
|   LCD                 |
|   PLASMA              |
|  PORTABLE ELECTRONICS |
|   MP3 PLAYERS         |
|    FLASH              |
|   CD PLAYERS          |
|   2 WAY RADIOS        |
|    FRS                |
+-----------------------+
</pre>

<p>This approach works equally well to delete a node and all its children:</p>

<pre>LOCK TABLE nested_category WRITE;


SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1
FROM nested_category
WHERE name = 'MP3 PLAYERS';


DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;


UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;
UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;

UNLOCK TABLES;
</pre>

<p>And once again, we query to see that we have successfully deleted an entire sub-tree:</p>

<pre>SELECT CONCAT( REPEAT( ' ', (COUNT(parent.name) - 1) ), node.name) AS name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;


+-----------------------+
| name                  |
+-----------------------+
| ELECTRONICS           |
|  TELEVISIONS          |
|   TUBE                |
|   LCD                 |
|   PLASMA              |
|  PORTABLE ELECTRONICS |
|   CD PLAYERS          |
|   2 WAY RADIOS        |
|    FRS                |
+-----------------------+
</pre>

<p>The other scenario we have to deal with is the deletion of a parent
node but not the children. In some cases you may wish to just change
the name to a placeholder until a replacement is presented, such as
when a supervisor is fired. In other cases, the child nodes should all
be moved up to the level of the deleted parent:</p>

<pre>LOCK TABLE nested_category WRITE;


SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1
FROM nested_category
WHERE name = 'PORTABLE ELECTRONICS';


DELETE FROM nested_category WHERE lft = @myLeft;


UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;
UPDATE nested_category SET rgt = rgt - 2 WHERE rgt &gt; @myRight;
UPDATE nested_category SET lft = lft - 2 WHERE lft &gt; @myRight;

UNLOCK TABLES;
</pre>

<p>In this case we subtract two from all elements to the right of the
node (since without children it would have a width of two), and one
from the nodes that are its children (to close the gap created by the
loss of the parent's left value). Once again, we can confirm our
elements have been promoted:</p>

<pre>SELECT CONCAT( REPEAT( ' ', (COUNT(parent.name) - 1) ), node.name) AS name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
GROUP BY node.name
ORDER BY node.lft;


+---------------+
| name          |
+---------------+
| ELECTRONICS   |
|  TELEVISIONS  |
|   TUBE        |
|   LCD         |
|   PLASMA      |
|  CD PLAYERS   |
|  2 WAY RADIOS |
|   FRS         |
+---------------+
</pre>

<p>Other scenarios when deleting nodes would include promoting one of
the children to the parent position and moving the child nodes under a
sibling of the parent node, but for the sake of space these scenarios
will not be covered in this article.</p>

<h3>Final Thoughts</h3>

<p>While I hope the information within this article will be of use to
you, the concept of nested sets in SQL has been around for over a
decade, and there is a lot of additional information available in books
and on the Internet. In my opinion the most comprehensive source of
information on managing hierarchical information is a book called <a href="http://www.openwin.org/mike/books/index.php/trees-and-hierarchies-in-sql">Joe Celko's Trees and Hierarchies in SQL for Smarties</a>,
written by a very respected author in the field of advanced SQL, Joe
Celko. Joe Celko is often credited with the nested sets model and is by
far the most prolific author on the subject. I have found Celko's book
to be an invaluable resource in my own studies and highly recommend it.
The book covers advanced topics which I have not covered in this
article, and provides additional methods for managing hierarchical data
in addition to the Adjacency List and Nested Set models.</p>

<p>In the References / Resources section that follows I have listed
some web resources that may be of use in your research of managing
hierarchal data, including a pair of PHP related resources that include
pre-built PHP libraries for handling nested sets in MySQL. Those of you
who currently use the adjacency list model and would like to experiment
with the nested set model will find sample code for converting between
the two in the <a href="http://www.sitepoint.com/article/hierarchical-data-database">Storing Hierarchical Data in a Database</a> resource listed below.</p>








 </div> 
</div> 
<div id="footer">

    <div class="links">
        <ul>
            <li class="top"><a href="http://www.mysql.com/products/">Products</a></li>
	    <li><a href="http://www.mysql.com/products/enterprise/">MySQL Enterprise</a></li>
	    <li><a href="http://www.mysql.com/products/database/cluster/">MySQL Cluster</a></li>
	    <li><a href="http://www.mysql.com/oem/">MySQL Embedded (OEM/ISV)</a></li>
	    <li><a href="http://www.mysql.com/products/dw/">MySQL Data Warehouse</a></li>
	    <li><a href="http://www.mysql.com/products/backup/">MySQL Backup &amp; Recovery</a></li>
	    <li><a href="http://www.mysql.com/products/workbench/">MySQL Workbench</a></li>
	    <li><a href="http://www.mysql.com/products/connector/">MySQL Connectors</a></li>
	    <li><a href="http://shop.mysql.com/">Online Shop</a></li>
        </ul>
    </div>
    
    <div class="links">
        <ul>
            <li class="top"><a href="http://dev.mysql.com/downloads/">Downloads</a></li>
            <li><a href="http://dev.mysql.com/downloads/mysql/">MySQL Community Server</a></li>
            <li><a href="http://dev.mysql.com/downloads/enterprise/">MySQL Enterprise</a></li>
            <li><a href="http://dev.mysql.com/downloads/mysql-proxy/">MySQL Proxy</a></li>
            <li><a href="http://dev.mysql.com/downloads/cluster/">MySQL Cluster</a></li>
            <li><a href="http://dev.mysql.com/downloads/workbench/">MySQL Workbench</a></li>
            <li><a href="http://dev.mysql.com/downloads/gui-tools/">GUI Tools</a></li>
            <li><a href="http://dev.mysql.com/downloads/connector/">Connectors</a></li>
            <li><a href="http://downloads.mysql.com/archives.php">Archives</a></li>
            <li><a href="http://downloads.mysql.com/snapshots.php">Snapshots</a></li>
            <li><a href="http://dev.mysql.com/downloads/mirrors.html">Mirrors</a></li>
        </ul>
    </div>
    
    <div class="links">
        <ul>
            <li class="top"><a href="http://dev.mysql.com/">Developer Zone</a></li>
	    <li><a href="http://dev.mysql.com/doc/">Documentation</a></li>
            <li><a href="http://dev.mysql.com/librarian/">Librarian</a></li>
            <li><a href="http://dev.mysql.com/articles/">Developer Articles</a></li>
            <li><a href="http://forums.mysql.com/">Forums</a></li>
            <li><a href="http://bugs.mysql.com/">Bugs</a></li>
            <li><a href="http://forge.mysql.com/">Forge</a></li>
            <li><a href="http://planet.mysql.com/">Planet MySQL</a></li>
            <li><a href="http://labs.mysql.com/">Labs</a></li>
            <li><a href="http://forge.mysql.com/wiki/Category:MySQLUserGroups">MySQL Meetups</a></li>
            <li><a href="http://dev.mysql.com/guilds/">Guilds</a></li>
            <li><a href="http://lists.mysql.com/">Lists</a></li>

        </ul>
    </div>


    <div class="links">
        <ul>
            <li class="top"><a href="http://www.mysql.com/about/">About MySQL</a></li>
            <li><a href="http://www.mysql.com/about/contact/">Contact Us</a></li>
            <li><a href="http://www.mysql.com/about/legal/">Legal</a></li>
            <li><a href="http://www.mysql.com/about/legal/mysql_web_privacy_policy.html">Privacy Policy</a></li>
            <li><a href="http://www.mysql.com/about/jobs/">Job Opportunities</a></li>
            <li><a href="http://www.mysql.com/sitemap.html">Site Map</a></li>
	            </ul>
    </div>
    
    
    <div id="search">
        <form id="footer_search" action="http://search.mysql.com/search" method="get">
            <input id="f_q" name="q" value="" class="swap_value" onfocus="clearSearchText();" type="text">
	    <input src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/footer_search_g.png" id="f_go" alt="Search" title="Search" value="Search" type="image">
        </form>
    </div>

</div><!-- End Footer -->
    
    
    <div id="copyright">© 1995-2008 MySQL AB, 2008- Sun Microsystems, Inc.</div>


    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script src="0315%20Managing%20Hierarchical%20Data%20in%20MySQL_files/ga.js" type="text/javascript"></script>
    <script type="text/javascript">
    var pageTracker = _gat._getTracker("UA-225536-3");
    pageTracker._trackPageview();
    </script>

</div></body></html>